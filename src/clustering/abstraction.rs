use crate::cards::observation::NodeObservation;
use std::{hash::Hash, u64};

/// Abstraction represents a lookup value for a given set of Observations.
///
/// - River: we use a u8 to represent the equity bucket, i.e. Equity(0) is the worst bucket, and Equity(50) is the best bucket.
/// - Pre-Flop: we do not use any abstraction, rather store the 169 strategically-unique hands as u64.
/// - Other Streets: we use a u64 to represent the hash signature of the centroid Histogram over lower layers of abstraction.
#[derive(Default, Copy, Clone, Hash, Eq, PartialEq, Debug, PartialOrd, Ord)]
pub struct NodeAbstraction(u64); // hash signature generated by the centroid histogram over lower layers of abstraction

impl NodeAbstraction {
    pub const N: u8 = 50;
    pub fn random() -> Self {
        Self(rand::random::<u64>())
    }
}

impl From<NodeObservation> for NodeAbstraction {
    fn from(observation: NodeObservation) -> Self {
        let equity = observation.equity();
        let quantile = equity * (Self::N - 1) as f32;
        let quantile = quantile.floor() as u8 as u64 + 1;
        Self::from(quantile)
    }
}

impl From<NodeAbstraction> for u64 {
    fn from(a: NodeAbstraction) -> Self {
        a.0
    }
}
impl From<u64> for NodeAbstraction {
    fn from(n: u64) -> Self {
        Self(n)
    }
}

/// Conversion to i64 for SQL storage.
impl From<NodeAbstraction> for i64 {
    fn from(abstraction: NodeAbstraction) -> Self {
        u64::from(abstraction) as i64
    }
}
impl From<i64> for NodeAbstraction {
    fn from(n: i64) -> Self {
        Self(n as u64)
    }
}

/// Bypass conversion to i64 for SQL storage and impl ToSql directly
impl tokio_postgres::types::ToSql for NodeAbstraction {
    fn to_sql(
        &self,
        ty: &tokio_postgres::types::Type,
        out: &mut bytes::BytesMut,
    ) -> Result<tokio_postgres::types::IsNull, Box<dyn std::error::Error + Sync + Send>> {
        i64::from(*self).to_sql(ty, out)
    }

    fn accepts(ty: &tokio_postgres::types::Type) -> bool {
        <i64 as tokio_postgres::types::ToSql>::accepts(ty)
    }

    fn to_sql_checked(
        &self,
        ty: &tokio_postgres::types::Type,
        out: &mut bytes::BytesMut,
    ) -> Result<tokio_postgres::types::IsNull, Box<dyn std::error::Error + Sync + Send>> {
        i64::from(*self).to_sql_checked(ty, out)
    }
}
