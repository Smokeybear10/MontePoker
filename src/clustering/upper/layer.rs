use super::histogram::Histogram;
use super::metric::Metric;
use super::projection::Projection;
use super::xor::Pair;
use crate::cards::observation::Observation;
use crate::cards::street::Street;
use crate::clustering::abstraction::Abstraction;
use std::collections::HashMap;

pub struct Layer {
    street: Street,
    metric: HashMap<Pair, f32>,
    observations: HashMap<Observation, (Histogram, Abstraction)>,
    abstractions: HashMap<Abstraction, (Histogram, Histogram)>,
}

impl Layer {
    /// async download from database to create initial River layer.
    pub async fn bottom() -> Self {
        crate::clustering::bottom::upload().await;
        crate::clustering::bottom::download().await
    }

    /// Yield the next layer of abstraction by kmeans clustering
    /// TODO; make this async and persist to database after each layer
    pub async fn raise(self) -> Self {
        let mut next = Self {
            street: self.street.prev(),
            metric: self.metric(),
            abstractions: self.abstractions(),
            observations: self.observations(),
        };
        next.kmeans(100);
        next
    }

    /// Run kmeans iterations.
    /// Presumably, we have been generated by a previous layer, with the exception of Bottom == River.
    /// After the base case, we trust that our observations, abstractions, and metric are correctly populated.
    fn kmeans(&mut self, iterations: usize) {
        for _ in 0..iterations {
            for (_, (data, last)) in self.observations.iter_mut() {
                let mut nearests = f32::MAX;
                let mut neighbor = Abstraction::default();
                for (abs, (mean, _)) in self.abstractions.iter_mut() {
                    let distance = self.metric.emd(data, mean);
                    if distance < nearests {
                        nearests = distance;
                        neighbor = abs.clone();
                    }
                }
                self.abstractions
                    .get_mut(&neighbor)
                    .expect("key from iteration, not default")
                    .0
                    .absorb(data);
                let _ = std::mem::replace(last, neighbor);
            }
        }
    }

    /// Calculate and return the metric using EMD distances between abstractions
    /// TODO
    /// this won't work for River because we have no emd.
    /// Need pattern match on street.
    fn metric(&self) -> HashMap<Pair, f32> {
        let ref centroids = self.abstractions;
        let mut metric = HashMap::new();
        for (i, (x, _)) in centroids.iter().enumerate() {
            for (j, (y, _)) in centroids.iter().enumerate() {
                if i > j {
                    let index = Pair::from((x, y));
                    let ref x = centroids.get(x).expect("kmeans histogram").0;
                    let ref y = centroids.get(y).expect("kmeans histogram").0;
                    let distance = self.metric.emd(x, y);
                    metric.insert(index, distance);
                }
            }
        }
        metric
    }

    #[rustfmt::skip]
    /// Generate all possible obersvations. Assign them to arbitrary abstractions. They will be overwritten during kmeans iterations. We start from River which comes from database from equity abstractions.
    fn observations(&self) -> HashMap<Observation, (Histogram, Abstraction)> {
        Observation::all(self.street.prev())
            .into_iter()
            .map(|upper| (upper, (self.observations.project(upper), Abstraction::default())))
            .collect()
    }

    /// K Means++ implementation yields initial histograms. Abstractions are random and require uniqueness.
    fn abstractions(&self) -> HashMap<Abstraction, (Histogram, Histogram)> {
        // 0. Initialize data structures
        let mut means = Vec::new();
        let ref mut observations = self.observations.values().map(|(histogram, _)| histogram);
        let ref mut rng = rand::thread_rng();
        use rand::distributions::Distribution;
        use rand::distributions::WeightedIndex;
        use rand::seq::SliceRandom;
        // 1. Choose 1st centroid randomly from the dataset
        let sample = observations
            .collect::<Vec<&Histogram>>()
            .choose(rng)
            .expect("non-empty lower observations")
            .to_owned()
            .clone();
        means.push(sample);
        // 2. Choose nth centroid with probability proportional to squared distance of nearest neighbors
        const K: usize = 100;
        while means.len() < K {
            let distances = observations
                .map(|histogram| {
                    means
                        .iter()
                        .map(|centroid| self.metric.emd(centroid, histogram))
                        .min_by(|a, b| a.partial_cmp(b).unwrap())
                        .expect("find minimum")
                })
                .map(|min| min * min)
                .collect::<Vec<f32>>();
            let choice = WeightedIndex::new(distances)
                .expect("valid weights")
                .sample(rng);
            let sample = observations
                .nth(choice)
                .expect("shared index with lowers")
                .clone();
            means.push(sample);
        }
        // 3. Collect histograms and label with arbitrary (random) Abstractions
        means
            .into_iter()
            .map(|mean| (Abstraction::random(), (mean, Histogram::default())))
            .collect::<HashMap<_, _>>()
    }
}
