use super::histogram::Histogram;
use std::hash::{DefaultHasher, Hash, Hasher};

#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug, PartialOrd, Ord)]
pub enum Abstraction {
    Distro(u64), // hash signature generated by the centroid histogram over lower layers of abstraction
    Equity(u8), // "percentile" (discrete) ranking of showown equity, assembled into 2% -wide buckets
}
impl Abstraction {
    pub const BUCKETS: u8 = 50;
}

impl std::ops::Add for Abstraction {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        match (self, other) {
            (Self::Equity(a), Self::Equity(b)) => Self::Equity(a + b),
            (Self::Distro(a), Self::Distro(b)) => Self::Distro(a ^ b),
            _ => panic!("incompatible abstraction types"),
        }
    }
}

impl From<u8> for Abstraction {
    fn from(e: u8) -> Self {
        Self::Equity(e)
    }
}

impl From<f32> for Abstraction {
    fn from(p: f32) -> Self {
        Self::Equity((p * Self::BUCKETS as f32) as u8)
    }
}

impl From<&Histogram> for Abstraction {
    fn from(histogram: &Histogram) -> Self {
        let ref mut hasher = DefaultHasher::new();
        histogram.hash(hasher);
        let bucket = hasher.finish();
        Self::Distro(bucket)
    }
}

impl From<Abstraction> for u64 {
    fn from(a: Abstraction) -> Self {
        match a {
            Abstraction::Equity(e) => e as u64,
            Abstraction::Distro(d) => d,
        }
    }
}
